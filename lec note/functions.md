#cs  #cs61a #Python

- primitive expression
- call expression
- name  

## v1
### welcome

**核心宗旨与观看要求：**

* **视频目的**：这些在线视频讲座的核心目的是让学生在参加现场讲座（live lecture）之前，提前熟悉和掌握课程材料 。讲师强调，视频内容已经涵盖了课程所需的全部知识点 。
* **观看顺序**：学生被明确要求**务必**在参加现场讲座前完成视频的观看 。
* **学习流程**：推荐的学习流程是“先看视频，再来上课”（watch first, come to lecture next）。现场讲座将假定学生已通过视频掌握了基础概念，并会直接运用这些知识进行问题求解和深入探讨 。

**视频制作背景：**

* **内容迭代与更新**：讲师解释了为何他在视频中看起来年龄和背景多变。这是因为课程视频是在一个很长的时间跨度内录制的 。
* **持续优化**：一旦有更好的讲解方式或更贴切的示例出现，讲师就会重新录制相关部分。
* **新旧融合**：因此，最终呈现的课程是由不同时期录制的视频片段（部分内容可能已有十年之久，部分则是全新的）精心编排而成的，旨在为学生提供一条逻辑连贯、内容最优的学习路径 。



## v2

#### 核心概念：调用表达式 (Call Expressions)

* **定义**：在编程中，调用表达式指的是对一个或多个参数（arguments）调用一个函数（function）的过程。
* **结构**:
    * **操作符 (Operator)**：括号前面的部分，即被调用的函数名（例如 `add`）。
    * **操作数 (Operands)**：括号内用逗号分隔的部分，即传递给函数的参数（例如 `1 + 1`, `3`）。
    * 操作符和操作数本身也都是表达式，它们会被求值以获得具体的值。

#### 调用表达式的求值过程

1.  **求值操作符**：首先对操作符表达式进行求值，以确定具体要调用的是哪个函数。
2.  **求值操作数**：接着对所有操作数表达式进行求值，以获得传递给函数的参数值。
3.  **应用函数**：最后，将操作符求得的函数应用于操作数求得的参数值上。

* **术语说明**：
    * **操作符 (Operator)** 和 **操作数 (Operand)** 用来描述表达式的组成部分。
    * **函数 (Function)** 和 **参数 (Argument)** 用来描述在求值过程中实际操作的值。

#### 嵌套调用表达式 (Nested Call Expressions)

* 当调用表达式中包含其他调用表达式时，求值过程会从内到外依次进行。
* 视频以 `mul(add(4, mul(4, 6)), add(3, 5))` 为例，展示了内部的 `mul(4, 6)` 和 `add(3, 5)` 会先被求值，然后其结果再作为外部 `add` 和 `mul` 函数的参数。

#### 表达式树 (Expression Tree) 与递归 (Recursion)

* **表达式树**：这种重复应用相同求值规则的过程，可以用一种叫做“表达式树”的结构来可视化。
* **递归**：一个过程调用其自身被称为递归。在求值嵌套表达式时，我们实际上是在递归地应用调用表达式的求值规则。这个强大的概念允许我们用一个简单的规则来完成复杂的工作。

## v3

#### 核心概念：Python 中的名称 (Names)

本视频介绍了在 Python 中名称是如何工作的，涵盖了赋值语句、导入语句和用户自定义函数。

#### 主要内容

* **导入语句 (Import Statements)**
    * 可以通过 `import` 语句来引入并使用模块中已有的名称。
    * 例如，从 `math` 模块中导入 `pi`，之后就可以在代码中使用 `pi` 这个名称来代表圆周率。
    * 同样地，也可以导入函数，如 `sin` 函数。

* **赋值语句 (Assignment Statements)**
    * 可以使用赋值语句来定义自己的名称。
    * 赋值语句将左侧的名称绑定到右侧表达式求值后的结果上。例如，`radius = 10` 将名称 `radius` 绑定到数值 `10`。
    * 可以在一条语句中为多个名称赋值。
    * **重要提示**：赋值是绑定值，而不是绑定公式。如果一个变量是基于另一个变量计算得出的（例如 `area = pi * radius * radius`），当后者（`radius`）的值改变时，前者（`area`）的值不会自动更新。
    * 赋值语句也可以将一个名称赋予一个函数，这意味着多个名称可以指向同一个函数。

* **def 语句 (用户自定义函数 - User-Defined Functions)**
    * `def` 语句允许你创建自己的函数。
    * 例如，`def square(x): return x * x` 定义了一个名为 `square` 的函数。
    * **关键优势**：函数每次被调用时，都会重新对其返回表达式进行求值。这有助于在变量值发生变化时，保持依赖于这些变量的计算结果<mark style="background: #ADCCFFA6;">同步更新</mark>。
    * 例如，将 `area` 定义为一个函数 `def area(): return pi * radius * radius`，可以确保每当 `radius` 的值改变后，调用 `area()` 总能得到最新的面积。

* **表达式 (Expressions)**
    * 视频回顾了基本表达式的类型，包括：
        * **原始表达式 (Primitive Expressions)**：如数字、名称和字符串。
        * **调用表达式 (Call Expressions)**：由操作符、括号和操作数组成。

* **思考题**
    * 视频最后通过一个较为复杂的例子，测试观众对在一系列赋值和函数调用中，名称是如何被求值的理解。


## v4

# 环境图

## 简介
- **环境图 (Environment Diagrams)** 是一种可视化Python解释器执行过程的工具。
- 它们有助于跟踪名称的含义以及它们与内存中值的绑定关系。

## 用途
- 可视化解释过程。
- 理解程序的执行方式。

## 结构
- **代码 (左侧)**:
  - 显示常规的Python代码。
  - 箭头指示当前和下一条要执行的代码行。
  - 灰色箭头表示已执行的代码行，红色箭头指向下一条要执行的代码行。
- **帧 (右侧)**:
  - 跟踪名称和值之间的绑定。
  - 在一个帧内，一个名称最多可以绑定到一个值。如果一个名称被重新绑定，旧的绑定就会丢失。

## 在线Python导师 (Online Python Tutor)
- 视频演示了一个名为“在线Python导师”的在线工具，它可以自动生成这些图表。
- 用户可以输入代码，逐步可视化其执行过程，并观察名称如何与值绑定。
- 强烈推荐使用此工具进行调试和理解程序行为。

## 赋值语句的执行规则
1. 从左到右计算等号右侧的所有表达式。
2. 计算完所有表达式后，将等号左侧的所有名称与它们对应的结果值绑定。

## 复杂示例
视频通过一个涉及函数重新赋值和嵌套调用表达式的复杂示例，逐步说明了环境图如何随着执行的每一步而变化：

- 将 `f` 从 `min` 重新绑定到 `max`，导致与 `min` 的旧绑定丢失。
- 将 `g` 绑定到 `min`，将 `h` 绑定到 `max`。
- 将内置的 `max` 名称重新绑定到 `min` 函数。
- 逐步计算一个复杂的嵌套调用表达式，演示了如何根据环境中当前的绑定来计算运算符和操作数。复杂表达式的最终计算结果为3。

## v5


# 定义函数 (Defining Functions)

## 抽象与函数定义 (Abstraction and Function Definition)
- **抽象 (Abstraction)**: 将复杂事物命名，并将其视为一个整体，无需关心其内部细节。
- **函数定义 (Function Definition)**: 一种强大的抽象方法，它将一个名称与一个复杂的表达式、语句或一系列语句绑定在一起。

## 函数定义的语法 (`def` 语句)
- 使用 `def` 关键字来定义函数。
- **通用语法**:
  ```python
  def <函数名>(<形式参数>):
      <函数体>
```
```python
def <name>(<formal parameters>):
	fynction body 
	return <return expression>
```
- **函数签名 (Function Signature)**: `def` 和冒号之间的代码行，用于指定函数名及其形式参数。形式参数是引用传入函数的参数值的名称。
    
- **函数体 (Function Body)**: `def` 语句第一行之后所有缩进的代码。它通常包含一个 `return` 语句，后跟一个返回表达式。
    

## `def` 语句的执行过程

1. 创建一个具有指定签名的新函数。
    
2. 函数体（缩进的代码）作为函数的一部分被“储存”起来，但不会立即执行。
    
3. 在当前环境的帧中，将函数名与这个新创建的函数绑定。
    

## 调用（应用）用户定义函数的步骤

1. 添加一个局部帧，形成一个新的环境。
    
2. 在这个新的局部帧中，将函数的形式参数与其实参值绑定。
    
3. 在这个新环境中执行函数体。
    

## 示例：数字平方

- **代码**:
    
    Python
    
    ```
    def square(x):
        return mole(x, x)
    
    square(-2)
    ```
    ![[20学习/images/functions.png]]
- **执行过程**:
    
    1. `def square(x)` 创建函数并将其与名称 `square` 绑定。
        
    2. 调用 `square(-2)` 时，会引入一个新的局部帧。
        
    3. 在该局部帧中，`x` 与 `-2` 绑定。
        
    4. 执行 `mole(x, x)`，最终返回 `4`。
![[20学习/images/functions-1.png]]

## 环境图与名称查找 (Environment Diagrams and Name Lookup)

- **环境图的组成**:
    
    - 内置函数
        
    - 用户定义的函数及其形式参数
        
    - 局部帧
        
    - 返回值
        
- **环境 (Environment)**: 帧的序列，其中帧是名称和值之间的绑定。
    
- **名称查找 (Name Lookup)**: 从最早的帧（例如，局部帧，然后是全局帧）开始，按顺序检查环境。使用在第一个找到名称的帧中与该名称绑定的值。
    

## 自引用函数名示例

- **代码**:
    
    Python
    
    ```
    def square(square):
        return mole(square, square)
    ```
    
- **解释**:
    
    - 尽管函数名 `square` 与其形式参数 `square` 相同，但函数调用仍然可以正常工作。
        
    - 这是因为在执行期间，函数体中的名称 `square` 引用的是在局部帧中绑定的形式参数（它持有参数值，例如 -2），而不是全局函数 `square`。
        
    - 这证明了环境中名称查找规则的重要性。
        

## v6


# 打印值与表达式求值 (Printing Values vs. Evaluating Expressions)

## 表达式求值与打印的区别 (Evaluating Expressions vs. Printing)
- 在交互式Python解释器中输入一个表达式，它会自动显示该表达式的值。例如，输入 `-2` 会显示 `-2`。
- 使用 `print()` 函数打印一个值也会显示它，但有细微差别。例如，`print('go Bears')` 显示 `go Bears`（不带引号），而直接对 `'go Bears'` 求值则会显示带引号的 `'go Bears'`。这表明解释器显示求值的表达式的方式与 `print()` 输出值的方式之间存在区别。

## `None` 值
- 在Python中，`None` 代表没有值或“无”。
- 如果直接对 `None` 求值，解释器不会显示任何内容。
- 但是，如果 `print(None)`，它会明确显示单词 `None`。
- 没有明确返回值的函数会隐式返回 `None`。例如，一个计算 `x * x` 但缺少 `return` 语句的函数 `does_not_square(x)` 将返回 `None`。当调用此类函数时，返回的 `None` 不会自动被解释器显示。
- 尝试对 `None` 进行操作（例如，`16 + 4`，其中 `16` 绑定到 `None`）将导致 `TypeError`，因为 `NoneType` 与整数操作不兼容。

## 纯函数与非纯函数 (Pure vs. Non-Pure Functions)
- **纯函数 (Pure functions)** 仅根据其输入返回值，并且没有其他可观察到的效果（副作用）。例如 `abs()` (绝对值) 和 `pow()` (幂)。它们就像封闭的管道，接收输入并产生输出。
- **非纯函数 (Non-pure functions)** 不仅返回值，还具有**副作用 (side effects)**。
- `print()` 是一个非纯函数。它的返回值始终是 `None`，但其副作用是显示传递给它的值。这个副作用本身不是一个值，而是一个动作。

## 嵌套 `print()` 调用
- 视频通过像 `print(print(1), print(2))` 这样的嵌套 `print()` 调用来说明其行为，它会先输出 `1`，然后是 `2`，然后是 `None None`，最后最外层调用的 `None` 返回值没有明确的输出。
- 这种行为通过一个表达式树来解释：
    - 首先计算最内层的 `print(1)`。它作为副作用显示 `1` 并返回 `None`。
    - 然后计算 `print(2)`。它作为副作用显示 `2` 并返回 `None`。
    - 最后，最外层的 `print()` 接收到两个 `None` 值（从内层 `print` 调用返回）。它作为副作用显示 `None None`。
    - 整个嵌套表达式的最终返回值是 `None`，交互式解释器不会自动显示它。